// Generated by CoffeeScript 1.6.3

(function() {
  var Scene,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

var mouseX = mouseY = mouseZ = 0, ww = window.innerWidth, wh = window.innerHeight, wwh = ww/2, whh = wh/2,	entro = true,
	cntnr = document.getElementById('canvas'), navOn = false,	popped = '0',
	geom, mater, arw, x = y = z = pis = 0, pif = 1, ntro = true;		
var ttt, ttt2;
var tttG = new THREE.Geometry();
//var ulapS = new THREE.Geometry();
var lathe, clfMf = clfMf2 = munb = false;
var hol0, hol1, hol2, hol3, hol4, hol5, wHol, terr, terrW, tttO, tttH, mun, eglow, mun2, mirr;
var holE = new THREE.Geometry();
var torus, torus1, torus2, torus3;
var ww = window.innerWidth, wh = window.innerHeight, wwh = ww/2, whh = wh/2;
var ttts = new THREE.Group();
var bitWs = new THREE.Group();
var ulapS = new THREE.Group();
var istar = [];
var cld, cldS = [];
var twink = tttB = kld = false;
var groundMirror, mirrorMesh, verticalMirror, verticalMirrorMesh, mTor;
var planeGeo, planeGeoV=0, origV;
var glowM1, back;
var Pulsa, pulsas;

  Scene = (function() {
    function Scene(container) {
      this.animate = __bind(this.animate, this);
      this.onresize = __bind(this.onresize, this);
      var $container, ambientLight, auxLight, camera, controls, height, mainLight, renderer, scene, width;
      //var $container, ambientLight, auxLight, camera, height, mainLight, renderer, scene, width;
      $container = $(container);
      //width = $container.width();
      //height = $container.height();
	  width = window.innerWidth;
      height = window.innerHeight;
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, width / height, 0.01, 100000);
      camera.lookAt(new THREE.Vector3());
      scene.add(camera);
      renderer = new THREE.WebGLRenderer({
        //antialias: true, alpha: true, sortObjects: false
        antialias: true, alpha: true, sortObjects: false
      });
      renderer.setSize(width, height);
      //renderer.setClearColor(0x000000, 1);
      //renderer.setClearColor(0x393c4f, .5);
      //renderer.autoClear = false;
	//  renderer.setSize(ww, wh);
	renderer.shadowMapEnabled = true;
	renderer.shadowMapSoft = true;
	  renderer.shadowMapType = THREE.PCFShadowMap;
	  //renderer.shadowMapCullFace = THREE.CullFaceBack;
	  renderer.gammaInput = true;
	  renderer.gammaOutput = true;	
      $container.append(renderer.domElement);
/*      ambientLight = new THREE.AmbientLight(0x222222);
      scene.add(ambientLight);
      mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(1, 2, 4).normalize();
      scene.add(mainLight);
      auxLight = new THREE.DirectionalLight(0xffffff, 0.3);
      auxLight.position.set(-4, -1, -2).normalize();
      scene.add(auxLight);
*/	  
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      //controls.center.set(8.73, 0, 0);
      //controls.center.set(0, 0, 8);
      controls.center.set(0, 0, 0);
      controls.autoRotateSpeed = .4;
      //controls.autoRotate = true;
		controls.minDistance = 3;
		//controls.maxDistance = 80;
		controls.maxDistance = 400;
		//controls.enableDamping = true;
		//controls.damping = 0.2;	  
		//controls.maxPolarAngle = Math.PI/1.88;
		//controls.maxPolarAngle = Math.PI/1.8;
		//controls.maxPolarAngle = Math.PI/1.2;
      //camera.position.copy(controls.center).add(new THREE.Vector3(2, 6, 9));
      //camera.position.copy(controls.center).add(new THREE.Vector3(0, 4, 32));
      //camera.position.copy(controls.center).add(new THREE.Vector3(0, 3, 24));
      camera.position.copy(controls.center).add(new THREE.Vector3(0, 3, 26));
      $(window).resize(this.onresize);
      this.$container = $container;
      this.camera = camera;
      this.scene = scene;
      this.renderer = renderer;
      this.controls = controls;
	  
/* Author: Armstrong Chiu
   URL: http://thewebdesignerpro.com/     */

/*function gradTexture(color) {
    var c = document.createElement("canvas");
    var ct = c.getContext("2d");
    c.width = 16; c.height = 512;
    var gradient = ct.createLinearGradient(0,0,0,256);
    var i = color[0].length;
    while(i--){ gradient.addColorStop(color[0][i],color[1][i]); }
    ct.fillStyle = gradient;
    ct.fillRect(0,0,16,512);
    var texture = new THREE.Texture(c);
    texture.needsUpdate = true;
    return texture;
}*/
   
  
//scene.fog = new THREE.FogExp2( 0x515763, 0.018 );
//scene.fog = new THREE.FogExp2( 0x4b5264, 0.018 );
//scene.fog = new THREE.FogExp2( 0x83656d, 0.018 );
//scene.fog = new THREE.FogExp2( 0x976d84, 0.015 );
//scene.fog = new THREE.FogExp2( 0x83656d, 0.006 );
//scene.fog = new THREE.FogExp2( 0x43494d, 0.006 );
//scene.fog = new THREE.FogExp2( 0x3d4347, 0.0026 );
scene.fog = new THREE.FogExp2( 0x3d4347, 0.0015 );
var alight = new THREE.AmbientLight( 0x222222 );
scene.add( alight );
//var light = new THREE.PointLight( 0xffffff, 6, 70 );
//var light = new THREE.PointLight( 0xffffff, 6, 80 );
//light = new THREE.PointLight( 0xffffff, 11, 80 );
//light = new THREE.PointLight( 0xffffff, 12, 90 );
light = new THREE.PointLight( 0xffffff, 12, 400 );
light.position.set( 0, 10, -200 );
//light.position.set( 0, 9, -28 );
scene.add( light );
//var pointLightHelper = new THREE.PointLightHelper( light, 1 );
//scene.add( pointLightHelper );
//var spotL = new THREE.SpotLight( 0xffffff, 5, 300, Math.PI/3 );
//spotL2 = new THREE.SpotLight( 0xffffff, 1, 500, Math.PI/3 );
spotL = new THREE.SpotLight( 0xffffff, 1, 500, Math.PI/3 );
//spotL = new THREE.SpotLight( 0xffffff, 1, 500, Math.PI/4 );
//spotL2.position.set( 0, 15, -300 );
spotL.position.set( 0, 10, -200 );
spotL.onlyShadow = true;
spotL.castShadow = true;
//spotL2.castShadow = true;
//spotL.shadowBias = 0.1;
spotL.shadowMapWidth = 1024;
spotL.shadowMapHeight = 1024;
spotL.shadowDarkness = 0.35;
//spotL.shadowCameraNear = 40;
spotL.shadowCameraNear = 10;
spotL.shadowCameraFar = 500;
//spotL.shadowCameraFov = 86;
//spotL.shadowCameraFov = 60;
spotL.shadowCameraFov = 80;
spotL.shadowBias = -0.00002;
//spotL.shadowCameraVisible = true;
//spotL2.shadowCameraVisible = true;
scene.add( spotL );
//scene.add( spotL2 );
//var spotlH = new THREE.SpotLightHelper(spotL, 5)
//scene.add( spotlH );
spotL.lookAt(scene.position);
//spotL2.lookAt(scene.position);


   
var mouseX = mouseY = mouseZ = 0, ww = window.innerWidth, wh = window.innerHeight, wwh = ww/2, whh = wh/2,	controls, entro = true,
	cntnr = document.getElementById('canvas'), navOn = false,	popped = '0',
	geom, mater, arw, x = y = z = pis = 0, pif = 1, ntro = true;	
	
document.body.style.width = ww+'px';
document.body.style.height = wh+'px';	
cntnr.style.width = ww+'px';	
cntnr.style.height = wh+'px';
//cntnt.style.fontSize = ((ww+wh)/2)*0.02;

if (!Detector.webgl) Detector.addGetWebGLMessage();

var container = document.getElementById('canvas');
//container.style.opacity = 0;
var canva = document.createElement('canvas');
//canva.width = 32;
canva.width = 16;
//canva.height = window.innerHeight;
canva.height = 1024;
var context = canva.getContext('2d');
//var gradient = context.createLinearGradient(0, 0, 0, canvas.height/2);
var gradient = context.createLinearGradient(0, 0, 0, 1024);
/*gradient.addColorStop(0, "#11161d");
gradient.addColorStop(0.18, "#203040");
gradient.addColorStop(0.32, "#344256");
gradient.addColorStop(0.42, "#3e525d");
gradient.addColorStop(0.5, "#83656d");*/
gradient.addColorStop(0, "#01060d");
gradient.addColorStop(0.18, "#102030");
gradient.addColorStop(0.32, "#243246");
gradient.addColorStop(0.42, "#2e424d");
gradient.addColorStop(0.5, "#43494d");
gradient.addColorStop(0.7, "#3e525d");
gradient.addColorStop(0.8, "#344256");
gradient.addColorStop(0.9, "#203040");
gradient.addColorStop(1, "#11161d");
context.fillStyle = gradient;
context.fillRect(0, 0, canva.width, canva.height);
//container.style.background = 'url(' + canvas.toDataURL('image/png') + ')';
//container.style.backgroundSize = '32px 100%';
//container.style.backgroundSize = '16px 100%';
var bgTex = new THREE.Texture(canva);
bgTex.needsUpdate = true;
//var back = new THREE.Mesh( new THREE.IcosahedronGeometry(300,3), new THREE.MeshBasicMaterial( { map:gradTexture([[0.75,0.5,0.45, 0.2], ['#909090','#808080','#808080', '#444444']]), side:THREE.BackSide, depthWrite: false }  ));



//var clfMap = THREE.ImageUtils.loadTexture( "imj/shade/glyp2.jpg" );
var clfMap2 = THREE.ImageUtils.loadTexture( "imj/shade/glyp3.jpg", undefined, holT );
var diffMap = THREE.ImageUtils.loadTexture( "imj/shade/sand5.jpg", undefined, mfT );
var bwn = THREE.ImageUtils.loadTexture('imj/shade/mun3.png', undefined, bwan);
diffMap.wrapS = diffMap.wrapT = THREE.MirroredRepeatWrapping;
//clfMap.wrapS = clfMap.wrapT = clfMap2.wrapS = clfMap2.wrapT = THREE.RepeatWrapping;
clfMap2.wrapS = clfMap2.wrapT = THREE.RepeatWrapping;
//clfMap.repeat.set( 3, 2 );
clfMap2.repeat.set( 6, 2 );
diffMap.repeat.set( 32, 32);


function skyBG() {
var skyg = new THREE.IcosahedronGeometry(360, 2);
//var back = new THREE.Mesh( skyg, new THREE.MeshBasicMaterial( { map:bgTex, side:THREE.BackSide, depthWrite: false, fog: false }  ));
back = new THREE.Mesh( skyg, new THREE.MeshBasicMaterial( { map:bgTex, side:THREE.BackSide, fog: false, transparent: true, opacity: 0.99 }  ));
scene.add( back );
}
skyBG();

var loada = new THREE.OBJLoader();
//mfT();

geom = new THREE.Geometry();
for ( var i = 0; i < 2000; i ++ ) {
    var vertex = new THREE.Vector3();
    do {
        vertex.x = 1600 * Math.random() - 800;
        vertex.y = 1600 * Math.random() - 800;
        vertex.z = 1600 * Math.random() - 800;
    } while ( vertex.length() > 800 || vertex.length() < 400 );
    geom.vertices.push( vertex );
}
geom.computeBoundingSphere();
//mater = new THREE.PointCloudMaterial( { size: 1.5, sizeAttenuation: true } );
mater = new THREE.PointCloudMaterial( { size: 2.8 } );
var particle = new THREE.PointCloud( geom, mater );
scene.add( particle );


function mfT() {
loada.load(
	'objs/tttB.obj',
	function (object, materials) {
		//var geomW;
		var materl = new THREE.MeshLambertMaterial( {color: 0xb25b6c, map: diffMap, fog: true} );
		//var materl = new THREE.MeshBasicMaterial( {color: 0xb25b6c, wireframe: true} );
		object.traverse(function(child) {
			if (child instanceof THREE.Mesh) {
				child.geometry.computeVertexNormals();
				child.geometry.computeFaceNormals();			
				//child.material.shading = THREE.FlatShading;
				//child.material.shininess = 0;
				child.castShadow = true;
				child.receiveShadow = true;
				child.material = materl;					
				//geomW = child.geometry;
				terrW = new THREE.EdgesHelper( child, 0x696969, 1.0 );		
				scene.add( terrW );	
				terrW.material.transparent = true;
				terrW.material.opacity = 0.2;
			}
		});
		//object.castShadow = true;
		//object.receiveShadow = true;		
		terr = object;
		//terr.material = materl2;
		//terr.material.wireframe = true;
		//terr.material.needsUpdate = true;		

		//var terrW = new THREE.WireframeHelper( object, 0x777777 );
		scene.add(terr);
		//terr.scale.set(0.07,0.07,0.07);
		terr.position.set(0,-9.5,0);
		
		/*var flr = new THREE.Mesh( new THREE.CircleGeometry( 100 ), materl );
		flr.position.set(0,-9.5,0);
		flr.rotation.x = -Math.PI/2;
		scene.add(flr);*/
		
		//var terrW = new THREE.EdgesHelper( terr, 0x777777, 0.6 );		
		//scene.add( terrW );		
/*		
		//var materl2 = new THREE.MeshBasicMaterial( {color: 0xffffff, transparent: true, opacity: 0.5, wireframe: true} );
		var materl2 = new THREE.MeshLambertMaterial( { color: 0x777777, wireframe: true, opacity: 0.05, transparent: true, depthTest: false } );		
		//var materl2 = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, wireframe: true, blending: THREE.AdditiveBlending });		
		//var geomW = terr.geometry;
		//var terrW = object;
		//terrW.material = materl2;
		//terrW.material.wireframe = true;
		//terrW.material.needsUpdate = true;
		var terrW = new THREE.Mesh( geomW, materl2 );
		scene.add(terrW);
		//terrW.scale.set(1.001,1.001,1.001);
		terrW.position.set(0,-9.5,0);		
		//console.log(terrW);
*/		
			if (cIndex < cTotalFrames-1) {
				cXpos += cFrameWidth;
				cIndex += 1;
//				console.log('% '+percentComplete);
			}

		tttM();
	}
);
//mirR();
}


function bwan() {
	//var mater = new THREE.MeshLambertMaterial({ map: bwn, color: 0x336690, emissive: 0x566b76, side: THREE.FrontSide, overdraw: 0.5, fog: false });
	//var mater = new THREE.MeshPhongMaterial({ map: bwn, color: 0x0b2930, emissive: 0x1a202b, side: THREE.FrontSide, overdraw: 0.5, fog: false, shininess: 1 });
	//var mater = new THREE.MeshPhongMaterial({ map: bwn, color: 0x1b3940, emissive: 0x1a202b, side: THREE.FrontSide, wrapAround: true, overdraw: 0.5, fog: false, shininess: 2 });
	//var mater = new THREE.MeshPhongMaterial({ color: 0xaac0cf, map: bwn, wrapAround: true, overdraw: 0.5, fog: false, shininess: 2 });
	var mater = new THREE.MeshLambertMaterial({ color: 0xaac0cf, map: bwn, wrapAround: true, overdraw: 0.5, fog: false });
	//var mater = new THREE.MeshBasicMaterial({ color: 0xaac0cf, map: bwn, fog: false, shininess: 1 });
	mater.wrapRGB.set( 0.5, 0.5, 0.5 );
	//mater.wrapRGB.set( 0.25, 0.25, 0.25 );
	//mun = new THREE.Mesh( new THREE.SphereGeometry( 9, 24, 24 ), mater );
	//mun = new THREE.Mesh( new THREE.SphereGeometry( 12, 24, 24 ), mater );
	mun = new THREE.Mesh( new THREE.SphereGeometry( 30, 24, 24 ), mater );
	mun.position.set(0, 15, -300);
//	mun.rotation.x += .3;
//	mun.rotation.y -= 1.2;
	scene.add( mun );	

/*	
	//var geometry = new THREE.IcosahedronGeometry(8.9, 4);
	//var geometry = new THREE.IcosahedronGeometry(11.9, 4);
	var geometry = new THREE.IcosahedronGeometry(29.9, 4);
	var material = new THREE.MeshBasicMaterial( { color	: 0x000000, opacity: 0, transparent: true } );
	eglow = new THREE.Mesh( geometry, material );
	eglow.position.set(0, 12, -50);
	eglow.position.set(0, 12, -56);
	eglow.position.set(0, 12, -80);
	eglow.position.set(0, 15, -90);
	eglow.position.set(0, 15, -300);
	scene.add( eglow );	
	//var glowM1 = new THREEx.GeometricGlowMesh(eglow, 2.6, 0.05, 4.0);
	//glowM1 = new THREEx.GeometricGlowMesh(eglow, 24.0, 0.05, 18.0);
	//glowM1 = new THREEx.GeometricGlowMesh(eglow, 20.0, 0.05, 15.0);
	glowM1 = new THREEx.GeometricGlowMesh(eglow, 50.0, 0.05, 40.0);
	eglow.add(glowM1.object3d);
	var ouni = glowM1.outsideMesh.material.uniforms;
	ouni.glowColor.value.set('#65888e');	
*/

	//var mater = new THREE.MeshLambertMaterial({ color: 0x050505, map: clfMap2, wrapAround: true, overdraw: 0.5, fog: false });
	var mater = new THREE.MeshLambertMaterial({ color: 0x010101, wrapAround: true, overdraw: 0.5, fog: true });
	mater.wrapRGB.set( 0.2, 0.2, 0.2 );
	//mun2 = new THREE.Mesh( new THREE.SphereGeometry( 9, 24, 24 ), mater );
	//mun2 = new THREE.Mesh( new THREE.SphereGeometry( 24, 24, 24 ), mater );
	mun2 = new THREE.Mesh( new THREE.SphereGeometry( 18, 24, 24 ), mater );
	mun2.position.set(0, 8.5, -160);
	mun2.castShadow = true;
	//mun2.receiveShadow = true;
	scene.add( mun2 );	
	
	munb = true;
}


function ttt3() {
loada.load(
	'objs/ttt.obj',
	function (object, materials) {
		//var materl = new THREE.MeshPhongMaterial( {emissive: 0x3a1f18, color: 0x9d827b, fog: true} );
		var materl = new THREE.MeshPhongMaterial( {emissive: 0x3a1f18, color: 0x9d827b, shininess: 6, fog: true} );
		object.traverse(function(child) {
			if (child instanceof THREE.Mesh) {
				child.geometry.computeVertexNormals();
				child.geometry.computeFaceNormals();			
				//child.material.shading = THREE.FlatShading;
				//child.material.shininess = 0;
				child.castShadow = true;
				child.receiveShadow = true;
				child.material = materl;					
			}
		});
		//object.castShadow = true;
		//object.receiveShadow = true;		
		tttO = object;
		scene.add(tttO);
		tttO.scale.set(2,2,2.5);
		//tttO.scale.set(0.01,0.01,0.01);
		tttO.position.set(0,-9.85,-4);
		//tttO.castShadow = true;
		//tttO.receiveShadow = true;
		
			if (cIndex < cTotalFrames-1) {
				cXpos += cFrameWidth;
				cIndex += 1;
//				console.log('% '+percentComplete);
			}		
	}
);

}
ttt3();


function holT() {
	//var mmaterial = [new THREE.MeshPhongMaterial( { color: 0x413e2e, shading: THREE.FlatShading, shininess: 5, opacity: 0.5, transparent: true, map: clfMap, side: THREE.DoubleSide } ), 
		//	new THREE.MeshBasicMaterial( { color: 0x716e5e, wireframe: true, opacity: 0.5, transparent: true } ) ];	
	//var material1 = new THREE.MeshPhongMaterial( { color: 0x413e2e, shading: THREE.FlatShading, shininess: 5, opacity: 0.3, transparent: true, side: THREE.DoubleSide } );
	//var material1 = new THREE.MeshPhongMaterial( { color: 0x618eae, shading: THREE.FlatShading, shininess: 15, opacity: 0.5, transparent: true, side: THREE.DoubleSide, map: clfMap2 } );
	//var material1 = new THREE.MeshPhongMaterial( { shading: THREE.FlatShading, shininess: 15, opacity: 0.6, transparent: true, side: THREE.DoubleSide, map: clfMap2 } );
	var material1 = new THREE.MeshPhongMaterial( { shading: THREE.FlatShading, shininess: 15, map: clfMap2 } );
	var material2 = new THREE.MeshBasicMaterial( { color: 0x716e5e, wireframe: true, opacity: 0.1, transparent: true } );
	//torus = THREE.SceneUtils.createMultiMaterialObject( geometry, mmaterial ); 
	var geometry = new THREE.TorusGeometry( 8.6, 1.4, 3, 20 );	
	torus = new THREE.Mesh( geometry, material1 ); 
	scene.add( torus );	
	torus.rotation.set(Math.PI*-.5,0,0);
	torus.position.set(0, 10, 0);	
	var geometry = new THREE.TorusGeometry( 8.65, 1.45, 3.05, 20 );	
	torus1 = new THREE.Mesh( geometry, material2 ); 
	scene.add( torus1 );	
	torus1.rotation.set(Math.PI*-.5,0,0);
	torus1.position.set(0, 10, 0);		
/*	material1 = new THREE.MeshPhongMaterial( { shading: THREE.FlatShading, shininess: 15, opacity: 0.6, transparent: true, side: THREE.DoubleSide, map: clfMap } );	
	var geometry = new THREE.TorusGeometry( 7.2, 2.2, 4, 16 );
	//torus2 = THREE.SceneUtils.createMultiMaterialObject( geometry, mmaterial ); 
	torus2 = new THREE.Mesh( geometry, material1 ); 
	torus2.scale.set(.5,.5,.5);	
	torus2.rotation.set(Math.PI*-.5,0,0);
	torus2.position.set(0, 10, 8);	
	torus2.position.set(0, 10, 0);	
	scene.add( torus2 );		
	var geometry = new THREE.TorusGeometry( 7.25, 2.25, 4.05, 16 );
	torus3 = new THREE.Mesh( geometry, material2 ); 
	torus3.scale.set(.5,.5,.5);	
	torus3.rotation.set(Math.PI*-.5,0,0);
	torus3.position.set(0, 10, 8);	
	torus3.position.set(0, 10, 0);	
	scene.add( torus3 );	*/
	clfMf2 = true;
	
/*	torus.visible = false;
torus1.visible = false;
torus2.visible = false;
torus3.visible = false;*/
}
//holT();


function klouD() {
loada.load(
	'objs/swip2.obj',
	function (object, materials) {
		var materl = new THREE.MeshLambertMaterial( {color: 0x999999, emissive: 0x333333, fog: true, transparent: true, opacity: 0.3} );
		object.traverse(function(child) {
			if (child instanceof THREE.Mesh) {
				child.geometry.computeVertexNormals();
				child.geometry.computeFaceNormals();			
				//child.material.shading = THREE.FlatShading;
				//child.material.shininess = 0;
				child.castShadow = true;
				//child.receiveShadow = true;
				child.material = materl;					
			}
		});
		for (var i=0; i<12; i++) {
			cldS[i] = object.clone();
			var y = Math.random() - 0.5;
			do {
				var x = Math.random() - 0.5, z = Math.random() - 0.5;
			} while ( Math.abs(x) < .15 && Math.abs(z) < .15 );	
			cldS[i].position.set(x,y,z);
			cldS[i].position.normalize();
			cldS[i].position.multiplyScalar( 44 );
			cldS[i].position.y = 9 * Math.random() + 3;
			//cld.scale.set(Math.random()*4+11,Math.random()*3+3,1);
			//cldS[i].rotation.y = -Math.PI/2;
			ulapS.add(cldS[i]);
			cldS[i].lookAt( scene.position );
			//console.log(cldS[i]);
		}
		scene.add(ulapS);
		kld = true;
	}
);
}
klouD();


function tttM() {
	//planeGeo = new THREE.PlaneBufferGeometry( 24, 24, 16, 16 );
	//planeGeo = new THREE.PlaneGeometry( 24, 24, 16, 16 );
	planeGeo = new THREE.PlaneGeometry( 20, 20, 16, 16 );
//	planeGeo = new THREE.CircleGeometry( 10, 64 );
	//planeGeo = mirr;
	planeGeoV = planeGeo.vertices.length;
//	planeGeoV = mirr.geometry.vertices.length;
	var origV = new Array(planeGeoV)
	for (var i = 0; i < planeGeoV; i++) {
		origV[i] = planeGeo.vertices[i].clone();
		//origV[i] = mirr.geometry.vertices[i].clone();
	}
	planeGeo._origV = origV;	
	
	//groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: ww, textureHeight: wh, color: 0x4a4c4d } );
	groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: ww, textureHeight: wh, color: 0x808080 } );
	mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
	//mirrorMesh = new THREE.Mesh( mirr.geometry, groundMirror.material );
	//mirrorMesh = mirr;
	//mirrorMesh.material = groundMirror.material;
	//mirrorMesh.material.needUpdate = true;	
	mirrorMesh.add( groundMirror );
	mirrorMesh.rotateX( - Math.PI / 2 );
	scene.add( mirrorMesh );
	mirrorMesh.position.set(0,-9.95,0);
	//groundMirror.material.uniforms.mirrorSampler.value = null;
	
	var planeGeo2 = new THREE.PlaneBufferGeometry( 20, 20 );
	verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: 8, textureHeight: 8, color: 0x808080 } );
	//verticalMirrorMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 60, 60 ), verticalMirror.material );
	verticalMirrorMesh = new THREE.Mesh( planeGeo2, verticalMirror.material );
	verticalMirrorMesh.add( verticalMirror );
	verticalMirrorMesh.position.z = -10;	
	verticalMirrorMesh.position.y = 0.05;
	verticalMirror.visibility = false;

	var material1 = new THREE.MeshPhongMaterial( { shading: THREE.FlatShading, shininess: 15, map: clfMap2 } );	
	var geometry = new THREE.TorusGeometry( 9, 1.9, 3, 20 );	
	mTor = new THREE.Mesh( geometry, material1 ); 
	scene.add( mTor );	
	mTor.rotation.set(Math.PI*-.5,0,0);
	mTor.position.set(0, -10.2, 0);
	mTor.castShadow = true;		
	mTor.receiveShadow = true;
		
	tttB = true;
}

	  
// http://mrl.nyu.edu/~perlin/noise/
var ImprovedNoise = function () {
	var p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,
		 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,
		 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,
		 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,
		 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,
		 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
		 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
		 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,
		 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,
		 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

	for (var i=0; i < 256 ; i++) {
		p[256+i] = p[i];
	}

	function fade(t) {
		return t * t * t * (t * (t * 6 - 15) + 10);
	}

	function lerp(t, a, b) {
		return a + t * (b - a);
	}

	function grad(hash, x, y, z) {
		var h = hash & 15;
		var u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
		return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
	}

	return {
		noise: function (x, y, z) {
			var floorX = ~~x, floorY = ~~y, floorZ = ~~z;
			var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;

			x -= floorX;
			y -= floorY;
			z -= floorZ;

			var xMinus1 = x -1, yMinus1 = y - 1, zMinus1 = z - 1;
			var u = fade(x), v = fade(y), w = fade(z);
			var A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;

			return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), 
							grad(p[BA], xMinus1, y, z)),
						lerp(u, grad(p[AB], x, yMinus1, z),
							grad(p[BB], xMinus1, yMinus1, z))),
					lerp(v, lerp(u, grad(p[AA+1], x, y, zMinus1),
							grad(p[BA+1], xMinus1, y, z-1)),
						lerp(u, grad(p[AB+1], x, yMinus1, zMinus1),
							grad(p[BB+1], xMinus1, yMinus1, zMinus1))));

		}
	}
}
	  
Pulsa = (function() {

	//var RINGCOUNT = 160;
	//var RINGCOUNT = 8;
	var RINGCOUNT = 14;
	//var SEPARATION = 20;
	var SEPARATION = 10;
	//var SEPARATION = 120;
	//var INIT_RADIUS = 50;
	//var INIT_RADIUS = 10;
	var INIT_RADIUS = 8;
	//var SEGMENTS = 512;
	//var SEGMENTS = 128;
	var SEGMENTS = 160;
	var VOL_SENS = 2;
	//var BIN_COUNT = 512;
	var BIN_COUNT = 256;

	var rings = ring = [];
	var levels = [];
	var colors = [];
	pulsas = new THREE.Object3D();
	var loopGeom;//one geom for all rings
	var perlin = new ImprovedNoise();
	var noisePos = 0;
	//var noisePos = -13;
	var freqByteData;
	var timeByteData;


	function init() {

		rings = [];
		levels = [];
		colors = [];

		////////INIT audio in
		freqByteData = new Uint8Array(analyser.frequencyBinCount);
		timeByteData = new Uint8Array(analyser.frequencyBinCount);
		
		//create ring geometry
		var loopShape = new THREE.Shape();
		loopShape.absarc( 0, 0, INIT_RADIUS, 0, Math.PI*2, false );
		loopGeom = loopShape.createPointsGeometry(SEGMENTS/2);
		loopGeom.dynamic = true;

		//create rings
		scene.add(pulsas);
		//pulsas.position.y = 6;
		//pulsas.position.y = 5;
		pulsas.rotation.x = -Math.PI/2;
		var scale = 1;
		for(var i = 0; i < RINGCOUNT; i++) {

			var m = new THREE.LineBasicMaterial( { color: 0xffffff,
				//linewidth: 1,
				transparent : true, 				
				opacity : 0,
				blending : THREE.AdditiveBlending
				//blending : THREE.NoBlending,
				//depthTest : false
			});
			
			var line = new THREE.Line( loopGeom, m);

			rings.push(line);
			//scale *= 1.05;
			scale *= 1.3;
			line.scale.x = scale;
			line.scale.y = scale;
			pulsas.add(line);

			levels.push(0);
			colors.push(0);
		}

/*			levels.push(0);
			colors.push(0);

		var geometry = new THREE.RingGeometry( 13.7, 14, 20 );
		var material = new THREE.MeshBasicMaterial( { color: 0xbbff00, side: THREE.DoubleSide } );
		//var material = new THREE.MeshLambertMaterial( { color: 0xbbff00, side: THREE.DoubleSide, transparent: true, opacity: 0.99 } );
		ring[0] = new THREE.Mesh( geometry, material );
		scene.add( ring[0] );
		ring[0].position.y = 10;
		ring[0].rotation.x = -Math.PI/2;
		ring[1] = ring[0].clone();
		ring[2] = ring[0].clone();
		ring[3] = ring[0].clone();
		scene.add( ring[1] );
		scene.add( ring[2] );
		scene.add( ring[3] );
		ring[1].scale.x = ring[1].scale.y = 1.5;
		ring[2].scale.x = ring[2].scale.y = 2;
		ring[3].scale.x = ring[3].scale.y = 2.5;
*/		
	}

	function remove() {
		if (pulsas){
			for(var i = 0; i < RINGCOUNT; i++) {
				pulsas.remove(rings[i]);
			}
		}
	}

	function update() {
		//console.log('lvupdate');
		analyser.getByteFrequencyData(freqByteData);
		analyser.getByteTimeDomainData(timeByteData);

		//add a new average volume onto the list
		var sum = 0;
		for(var i = 0; i < BIN_COUNT; i++) {
			sum += freqByteData[i];
		}
		var aveLevel = sum / BIN_COUNT;
		var scaled_average = (aveLevel / 256) * VOL_SENS; //256 is the highest a level can be
		levels.push(scaled_average);
		levels.shift(1);
//console.log(scaled_average);

		//add a new color onto the list
		noisePos += 0.005;
		//noisePos += 0.01;
		var n = Math.abs(perlin.noise(noisePos, 0, 0));
		colors.push(n);
		colors.shift(1);

/*		for(var j = 0; j < ring[0].geometry.vertices.length-1; j++) {
			ring[0].geometry.vertices[j].z = timeByteData[j]*.005;
			//console.log(timeByteData[j]);
		}
		ring[0].geometry.vertices[ring[0].geometry.vertices.length-1].z = ring[0].geometry.vertices[0].z;
		ring[0].geometry.verticesNeedUpdate = true;		
*/		
		//for(var i = 0; i < 4; i++) {
			//var ringId = 4 - i - 1;
//			var normLevel = levels[0] + 0.01; //avoid scaling by 0
			//ring[i].position.z = -8;
			//rings[i].material.linewidth = normLevel*3;
			//console.log(normLevel);
			//ring[i].material.opacity = normLevel;
		//	ring[i].scale.x = 1+normLevel;
//			ring[i].scale.y = 1+normLevel;
		//console.log(normLevel);
		//}
/*		ring[0].scale.x = 1+normLevel;
		ring[0].scale.y = 1+normLevel;		
		ring[1].scale.x = 1+normLevel+.5;
		ring[1].scale.y = 1+normLevel+.5;		
		ring[2].scale.x = 1+normLevel+1;
		ring[2].scale.y = 1+normLevel+1;		
		ring[3].scale.x = 1+normLevel+1.5;
		ring[3].scale.y = 1+normLevel+1.5;
		
		ring[0].rotation.z += 0.01;
		ring[1].rotation.z += 0.01;
		ring[2].rotation.z += 0.01;
		ring[3].rotation.z += 0.01;
*/		
		
		//write current waveform into all rings
		for(var j = 0; j < SEGMENTS; j++) {
			//loopGeom.vertices[j].z = timeByteData[j]*2;//stretch by 2
			loopGeom.vertices[j].z = timeByteData[j]*0.25;
			//loopGeom.vertices[j].z = timeByteData[j]*2 + 13;
		}
		// link up last segment
		loopGeom.vertices[SEGMENTS].z = loopGeom.vertices[0].z;
		loopGeom.verticesNeedUpdate = true;

		for( i = 0; i < RINGCOUNT ; i++) {
			var ringId = RINGCOUNT - i - 1;
			var normLevel = levels[ringId] + 0.01; //avoid scaling by 0
			var hue = colors[i];
//			rings[i].position.z = -8;
			rings[i].material.color.setHSL(hue, 1, normLevel);
			rings[i].material.linewidth = normLevel*3;
			//console.log(normLevel);
			//rings[i].material.opacity = normLevel;
			rings[i].material.opacity = normLevel*1.3;
			rings[i].scale.z = normLevel;
			//rings[i].scale.z = normLevel + 5;
		}
		//loopGeom.position.z = 13;

	
	}

	return {
		init:init,
		update:update,
		remove:remove,
		pulsas:pulsas
	};
}());


//    $('.player-play').click(function(e) {
//        loadSampleAudio();
//		if (!started){
			//Pulsa.init();
//		}	
//		e.preventDefault();	
//    });
	  
/*.player-play.addEventListener('click', function(e) {
	loadSampleAudio();
	e.preventDefault();	
});*/
	
/*function wavY() {
	//var timer = 0.005 * Date.now();
	for(var i = 0; i < planeGeo.vertices.length; i++) {
		//var orig = geom._origV[i];
		var posi = planeGeo.vertices[i];	
		//var angle = timer+posi.y*4;
		//var angle2 = timer+posi.z*5;
		//var angle3	= timer+posi.x*3;		
		//posi.z = orig.z+Math.sin(timer+i)* 0.1;
		//posi.x = orig.x+Math.sin(timer)* 0.05;
		//posi.y = orig.y+Math.cos(timer)* 0.05;		
		posi.z += Math.sin(timer)* 0.1;
		posi.x += Math.sin(timer)* 0.1;
		posi.y += Math.cos(timer)* 0.1;
	}
	planeGeo.verticesNeedUpdate = true;	
}	  */
	  
    }

    Scene.prototype.onresize = function() {
      var height, width, _ref;
      _ref = [this.$container.width(), this.$container.height()], width = _ref[0], height = _ref[1];
      //this.camera.aspect = width / height;
      //this.camera.updateProjectionMatrix();
      //return this.renderer.setSize(width, height);

	ww = window.innerWidth;
    wh = window.innerHeight,
	wwh = ww/2, whh = wh/2;	
	
	this.camera.aspect = ww / wh;
	this.camera.updateProjectionMatrix();
	return this.renderer.setSize( ww, wh );
	
/*	document.body.style.width = cntnr.style.width = ww+'px';
	document.body.style.height = cntnr.style.height = wh+'px';	*/
	  
    };

	function onWindowResize( event ) {
	ww = window.innerWidth;
    wh = window.innerHeight,
	wwh = ww/2, whh = wh/2;	
	
	document.body.style.width = cntnr.style.width = ww+'px';
	document.body.style.height = cntnr.style.height = wh+'px';	

	if (!playlstb) {
		var playy = $("#player").width() * -1;
		$("#player").css("right", playy);
		//  console.log(playy);	
	}
	
//if (ww > wh) {
//		cntnt.style.fontSize = cntnt2.style.fontSize = ((ww+wh)/2)*0.022+'px';
//	} else {
//		cntnt.style.fontSize = cntnt2.style.fontSize = ((ww+wh)/2)*0.028+'px';
//	}
}
window.addEventListener( 'resize', onWindowResize, false );		


    Scene.prototype.add = function(object) {
      return this.scene.add(object);
    };

    Scene.prototype.remove = function(object) {
      return this.scene.remove(object);
    };

    Scene.prototype.animate = function(callback) {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.animate(callback);
      });
      if (typeof callback === "function") {
        callback();
      }
	  

	  
	  var timer = new Date().getTime();
//	if (ttt2.position.y < -7.7) {
//		ttt2.position.y += 0.1;
//	} else {
		//ttt2.position.y = -7.7;
		//ttts.position.y = -7.7;
//		if ((clfMf) && (planim)) lathe.rotation.z += .01;	
		if ((clfMf2) && (planim)) {
		torus.rotation.z += .01;	
		torus1.rotation.z += .01;	
/*		torus2.rotation.x += Math.sin( timer * 0.001 )*.01;
		torus2.rotation.y -= Math.cos( timer * 0.001 )*.01;
		torus2.rotation.z -= .02;			
		torus3.rotation.x += Math.sin( timer * 0.001 )*.01;
		torus3.rotation.y -= Math.cos( timer * 0.001 )*.01;
		torus3.rotation.z -= .02;	*/
		}
//	}	  

/*		if (twink) {
			for (var i=0;i<53;i++) {
				istar[i].visible = !!Math.floor(Math.random()*2);
				//istar[i].material.opacity = Math.random()*0.9+0.1;
			//	istar[i].lookAt( this.camera.position );
			}
		}
*/
		
		ulapS.rotation.y += 0.0004;
		if (kld) {
			for (var i=0;i<12;i++) {
				cldS[i].lookAt( this.scene.position );
				//cldS[i].rotation.y = -Math.PI/2;
			}
		}		
	//wavY();

	
	if (planim && tttB) {
		for(var i = 0; i < planeGeoV; i++) {
			var orig = planeGeo._origV[i];
			var posi = planeGeo.vertices[i];	
			//var angle = timer+posi.y*4;
			//var angle2 = timer+posi.z*5;
			//var angle3	= timer+posi.x*3;		
			var tmer = timer*.004;
			//posi.x = orig.x+Math.sin(tmer)*0.05;
			//posi.y = orig.y+Math.sin(tmer)*0.05;		
			//posi.z = Math.sin(Math.sqrt((posi.x^2 + posi.y^2)));						
			//posi.z = orig.z+Parser.parse("posi.x^2 - posi.y^2").toJSFunction( ['posi.x','posi.y'] );
			//posi.x = orig.x+Math.sin(tmer)*0.05;
			//posi.y = orig.y+Math.sin(tmer)*0.05;		
			posi.x = orig.x+Math.sin(tmer)*0.05;			
			posi.y = orig.y+Math.sin(tmer)*0.05;			
			posi.z = orig.z+Math.cos(tmer+i)*0.1;			
			//posi.z += Math.sin(timer*0.001+i);
			//posi.x += Math.sin(timer*0.001);
			//posi.y += Math.cos(timer*0.001);
		}
		planeGeo.verticesNeedUpdate = true;		
		pulsas.position.y = 5;
		Pulsa.update();
//		console.log('play');
	}

	
	if (tttB) {
	//groundMirror.material.uniforms.mirrorSampler.value = [{ clipBias: 0.003, textureWidth: ww, textureHeight: wh, color: 0x3e4348 }];
	//groundMirror.material.uniforms.mirrorSampler.value = null;
	//groundMirror.material.uniforms.mirrorSampler.value = new THREE.WebGLRenderTarget( ww, wh );
	groundMirror.renderWithMirror( verticalMirror );		
	//groundMirror.material.uniforms.mirrorSampler.value = null;
	//console.log(groundMirror.material.uniforms.mirrorSampler.value);
	
	var backO = Math.max(Math.abs(this.camera.position.x),Math.abs(this.camera.position.y),Math.abs(this.camera.position.z));
	back.material.opacity = 0.99 - backO*.003;
	terrW.material.opacity = 0.2 - backO*.0006;
	
	}

	//light.intensity = Math.random()*30;
	//light.distance = Math.random()*60+20;
	if (notemsg==144) {
		if (light.intensity<28) light.intensity += .3;
	} else if (notemsg==128) {
		if (light.intensity>3) light.intensity -= .4;
	} else {
		light.intensity = 12;
	}
	//console.log(notemsg);

	
	if (munb) {
		//var pxz1=Math.sin(timer*.0002)*80, pxz2=Math.cos(timer*.0002)*80, pxz3=Math.sin(timer*.0002)*50, pxz4=Math.cos(timer*.0002)*50;
		//var pxz1=Math.sin(timer*.000025)*300, pxz2=Math.cos(timer*.000025)*300, pxz3=Math.cos(timer*.00005)*220, pxz4=Math.sin(timer*.00005)*220, 
		var pxz1=Math.sin(timer*.000025)*300, pxz2=Math.cos(timer*.000025)*300, pxz1b=Math.sin(timer*.000025)*200, pxz2b=Math.cos(timer*.000025)*200, 
			pxz3=Math.cos(timer*.00005)*160, pxz4=Math.sin(timer*.00005)*160, 
		    pxz5=Math.sin(timer*.000025)*200, pxz6=Math.cos(timer*.000025)*200;
		    //pxz5=Math.sin(timer*.000025)*160, pxz6=Math.cos(timer*.000025)*160;
		//mun.position.x = eglow.position.x = spotL.position.x = pxz1;
		//mun.position.z = eglow.position.z = spotL.position.z = pxz2;						
		mun.position.x = pxz1;
		mun.position.z = pxz2;						
		spotL.position.x = pxz5;
		spotL.position.z = pxz6;				
		mun2.position.x = pxz3;
		mun2.position.z = pxz4;		
		light.position.x = pxz5;
		light.position.z = pxz6;		
		//mun.position.x += Math.cos(timer*.001);
		//mun.position.z += Math.sin(timer*.001);
		//mun.position.z += Math.cos(timer*.0001)*8;				
	}	

		
	if ((mcount==1) && (tttB) && (!allL)) {
		if (pis<1) {
			pis += 0.05;
			document.getElementById( 'canvas' ).style.opacity = pis;
			document.getElementById( 'player' ).style.opacity = pis;
		} else {
			cXpos = cFrameWidth*20;
			cIndex = 20;
			
			document.getElementById( 'canvas' ).style.opacity = 1;
			document.getElementById( 'player' ).style.opacity = 1;
			//mcount = 0;
			allL = true;
			$('#sharer').show();
			$('#minfo2').show();	
			$('#minfo').show();	
			//buffAudio = new BuffAudio(audioCtx, audioBuffer);	
			if (window.location.hash) {			
//				console.log('scene - yhash');
				var hash = window.location.hash.slice(1);
				player.setTrack(parseInt(hash, 10) - 1);		
			}
			Pulsa.init();
			//controls.autoRotate = true;
			clearTimeout(myVar);
			//$('#loaderImage').hide();
			//$('#overLy1').hide(2000);
			$('#overLy1').fadeOut(4000);
		}
		//console.log('allL');
	} 
	/*else { 
		console.log(mcount); 
		console.log(tttB); 
		console.log(allL); 
	}*/
	
	
	
      this.controls.update();
      //this.renderer.clear();	
      return this.renderer.render(this.scene, this.camera);
	  
    };

    return Scene;

  })();

  this.Scene = Scene;

}).call(this);
